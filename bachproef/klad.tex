\chapter{\IfLanguageName{dutch}{React}{React}}
\label{ch:react}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

% Auteur expliciet vernoemen: \textcite{Knuth1998}
% Niet expliciet auteur vernoemen: 

%Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

%\begin{itemize}
%  \item context, achtergrond
%  \item afbakenen van het onderwerp
%  \item verantwoording van het onderwerp, methodologie
%  \item probleemstelling
%  \item onderzoeksdoelstelling
%  \item onderzoeksvraag
%  \item \ldots
%\end{itemize}

%=======================================================================
% KLAD
%=======================================================================

\section{\IfLanguageName{dutch}{Javascript}{Javascript}}
\label{sec:javascript}

De taal werd gecreëerd door Brendan Eich in 1995 in zijn tijd als werknemer bij Netspace Communications, zoals aangegeven in het artikel van ~\textcite{Aston2015}. In 1997 werd het een \gls{ecma} standaard en nu behoort het tot één van de meest gebruikte programmeertalen voor het web. Zoals de naam al vrijgeeft behoort javaScript tot de scripttalen, elke scripttaal is een programmeertaal in zijn eigen recht. Voorbeelden zijn: Node js, bash, Ruby, Perl, Python, \dots\\
Scripttalen worden veel gebruikt omdat ze eenvoudig, flexibel en gebruiksvriendelijk zijn. Het zijn talen geschreven voor een run-time omgeving en worden samen met de executie van de applicatie uitgevoerd. Ze moeten niet gecompileerd worden door een compiler.\\
JavaScript wordt veel gebruikt als client side programmeertaal. Alle geschreven javaScript documenten worden bij het navigeren naar een webpagina samen met alle \gls{html} en \gls{css} documenten opgehaald van de server. Alle geïmporteerde documenten worden daarna door de browser geïnterpreteerd aan de kant van de gebruiker.

\subsection{\IfLanguageName{dutch}{JavaScript-framework}{JavaScript-framework}}
\label{sec:jsFrameworks}

Frameworks bezorgen de programmeur een duidelijke structuur en gestandaardiseerde code. Telkens opnieuw code moeten opbouwen en schrijven rooft tijd en productiviteit. Afhankelijk op welk niveau de programmeertaal wordt gebruikt bestaan er 2 typen frameworks, frontend en backend.\\
Door de immense opkom van webapplicaties begin jaren 2000 werd de vraag naar javaScript en \gls{ajax} enorm groot. Het vraag overschot zorgde voor de onvermijdelijke behoefte aan javaScript-frameworks. De frameworks brengen een oplossing voor de problemen die zuivere javaScript vormt:

\begin{itemize}[label={}]
    \item \textbf{Browserafhankelijkheid}:
    JavaScript zelf is niet afhankelijk van de browser, maar er worden wel \gls{dom} manipulaties gedaan via javaScript. De \gls{dom} is wel afhankelijk van de browser. Er moet op basis van de browser extra code voorzien worden. \newline
    \item \textbf{Prototype programmeren}:
    Maakt geen gebruik van klassen. Er wordt een prototype gemaakt van een object dat kan dienen voor overerving, het heeft limieten. \newline
    \item \textbf{Geen code herbruikbaarheid}:
    De code kan niet op een functionele manier worden gebundeld voor hergebruik, wat noodzakelijk is wanneer de complexiteit toeneemt.
\end{itemize}

Voorbeelden van \gls{js}-frameworks zijn ReactJS, AngularJS, vue.js, Ember.js, \dots

\subsection{\IfLanguageName{dutch}{Javascript library}{Javascript library}}
\label{sec:jsLibrary}

Libraries zijn een geheel van voorgeprogrammeerde functies die kunnen gebruikt worden om een aanvulling te bieden tot de reeds beschikbare functionaliteiten die het framework in kwestie aanbied. Het aspect dat ze een aanvulling bieden maakt het development eenvoudiger en makkelijker uit te breiden. In deze tijd is het simpel om een library te gebruiken met een installatie via de package manager, daarna enkel nog een import om deze in scope te plaatsen. In figuur~\ref{fig:libraryImport} op pagina~\pageref{fig:libraryImport} wordt de \textit{styled} library geïmporteerd voor het stylen van \gls{html} elementen.\\
Sommige libraries worden aanzien als een eigen framework omdat zij full-stack capaciteiten hebben, wat wil zeggen dat ze zowel frontend als backend functionaliteiten voorzien.\\
ReactJS is één van zo'n frameworks. Meningen verschillen over de interpretatie, maar beide kunnen geaccepteerd worden met elk juiste gegronde argumenten. Mensen uit de branche zoals Tom Dale, Senior Staff Software Engineer bij LinkedIn en co-creator van Ember.js, verwijzen naar React als een framework waar en tegen de online documentatie van React het als een library omschrijft.

\begin{figure}[h!]
    \includegraphics[width=\linewidth]{ReactInScope.png}
    \caption{Importeren van een library}
    \label{fig:libraryImport}
\end{figure}

\section{\IfLanguageName{dutch}{Onderzoeksvraag}{Research question}}
\label{sec:onderzoeksvraag}

De kernvraag van deze scriptie: Hoe performantie op frontend niveau op een doelgerichte en innovatieve manier verbeteren in React web applicaties?\\
Performantie is een gegeven dat in de loop der jaren in de software wereld enorm op de voorgrond is gekomen. Met hoe snel technologie en software zich ontwikkeld is het moeilijk voor iedere software ontwikkelaar om bij te houden wat de best practices zijn op het gebied van performantie. In deze `modern age` is het vanzelfsprekend dat webpagina's en apps binnen de twee seconden reageren op interactie van de gebruiker. Uit het artikel van~\textcite{Mazaika2017} leiden we af dat de vraag naar developers en software bedrijven enorm toeneemt. Dit ten gevolge van de exponentiële groei in de vraag naar webapplicaties, mobiele applicaties en andere software. Elke dag worden zij op de proef gesteld om aan de noden van gebruikers te voldoen. Met de druk van steeds meer uitgebreide en evenement rijke gebruikersomgevingen is het noodzakelijk om stil te staan bij performantie.\\
Hoe meten we performantie? Welke oplossingen biedt React ons? Waar hangt performantie van af in webapplicaties? Wat zijn de veel voorkomende valkuilen? Bestaan er ondersteunende software? Welke innovatieve technieken kunnen we toepassen? Kunnen we een leidraad vormen voor frontend performantie binnen React web applicaties?


\section{\IfLanguageName{dutch}{React API}{React API}}
\label{sec:reactComponenten}

Door `React` in scope te plaatsen is er toegang tot de React top-level \gls{api}. De import is het aanspreekpunt voor de \gls{api} en maakt alle React library functionaliteiten aanspreekbaar.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{ReactInScope.png}
    \caption{React in scope}
    \label{fig:reactImport}
\end{figure}

\subsection{\IfLanguageName{dutch}{Pure component}{Pure component}}
\label{sec:pureComponent}

Pure component is exact hetzelfde als een gewoon component in React. Het verschil tussen beiden ligt hem in de lifecycle methode `shouldComponentUpdate()` die op een andere manier uitgevoerd wordt. Bij een normaal component zal er altijd een re-render uitgevoerd worden wanneer er iets aan props of state veranderd. In een pure component wordt er in shouldComponentUpdate shallow comparison gedaan van props en state.\\
Shallow comparison vergelijkt de waarden en referenties van de vorige props en state, met de volgende. Deze controle is goedkoop, zeker in vergelijking met het telkens re-renderen van een component. Het nadeel is dat er geen controle wordt gedaan voor de waarden in geneste objecten.\\
Een pure component gaat ervoor zorgen dat er minder re-renders gebeuren. Dit wordt ook overgedragen naar de kinderen van een pure component, daardoor is het af te raden om van componenten met kinderen pure components te maken.\\
\newline
Een component is best te veranderen naar een pure component wanneer het eenvoudige state en props bevat. Het gebruik van een pure component geeft een performantie boost zonder dat er veel aanpassingen moeten worden gedaan aan de intiële code. In figuur ~\ref{fig:extendPureComponent} wordt afgebeeld wat er moet worden veranderd om van een gewoon component een pure component te maken.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{ExtendPureComponent.png}
    \caption{Changing component to pure component}
    \label{fig:extendPureComponent}
\end{figure}

\subsection{\IfLanguageName{dutch}{React Memo}{React Memo}}
\label{sec:memo}

Memo is gelijkaardig aan het pure component principe, waarbij het helpt om rendering te controleren. Memoization is een techniek voor het optimaliseren van snelheid in computer programma's. Door de dure functies, die regelmatig worden uitgevoerd, op te slaan in het cache geheugen kunnen ze veel sneller uitgevoerd worden in de toekomst. React memo werkt op hetzelfde principe.\\
Als een component wordt gewikkeld in `React.memo()` wordt bij elke re-render enkel de delen die een re-render nodig hebben opnieuw gerendert. De React.memo functie werkt voor functionele component als een extensie van React.PureComponent.

%=======================================================================
% Hooks sub hoofdstuk
%=======================================================================

\subsection{\IfLanguageName{dutch}{Hooks}{Hooks}}
\label{sec:hooks}

Hooks biedt alles wat een klasse component kan, voor een functioneel component. Vóór Reactv16.8 was het gebruik van functionele componenten voor de presentatie van domme en eenvoudige \gls{ui} elementen. De komst van hooks brengt een volledige \gls{api} voor functionele componenten met zich mee om te fungeren als klasse componenten.\\

\subsubsection{\IfLanguageName{dutch}{useState}{useState}}
\label{sec:useState}

-- Inhoud over useState binnen hooks --

\subsubsection{\IfLanguageName{dutch}{useEffect}{useEffect}}
\label{sec:useEffect}

-- Inhoud over useEffect binnen hooks --

\subsubsection{\IfLanguageName{dutch}{useCallback}{useCallback}}
\label{sec:useCallback}

-- Inhoud over useCallback binnen hooks --

%=======================================================================
% React concepten hoofdstuk
%=======================================================================

\section{\IfLanguageName{dutch}{React concepten}{React concepts}}

\subsection{\IfLanguageName{dutch}{Bundling}{Bundling}}
\label{sec:bundeling}

Bij het maken van een React applicatie wordt de gehele code base onderverdeeld in componenten en functionaliteiten van third party libraries. De code van die componenten en third party libraries wordt in andere delen van de applicatie geimporteerd. Hoe meer code dat componenten importeren, hoe groter en complexer ze worden. De kost om javaScript code te parsen en compilen is enorm. De laadtijd van webpagina's stijgt samen met het groter en complexer worden van componenten, omdat meer code geparsed en gecompiled moet worden.\\
Bundeling zorgt dat alle geimporteerde documenten opgehaald worden en in één bundel gestoken. De bundel wordt meegegeven aan de webpagina waarmee het de volledige applicatie kan inladen.  

\subsection{\IfLanguageName{dutch}{Code splitting}{Code splitting}}
\label{sec:codeSplitting}

Bundlers zoals Webpack en Browserify doen automatisch aan bundling. De meeste bundlers voorzien oplossingen voor de complicaties die bundling kan meebrengen in verband met laadtijden van webpagina's.\\
Code splitting is één van de oplossingen voor het controleren van bundle grootes in een applicatie. Het principe helpt door \gls{js} code te verdelen in stukken en enkel de delen die nodig zijn, voor de gebruiker, op een bepaald moment in te laden. Zo wordt met een minimum aan code waarde gecreëerd voor de \gls{ui}.\\




\subsection{\IfLanguageName{dutch}{React virtual DOM}{React virtual DOM}}
\label{ch:reactVirtualDOM}

-- Inleiding tot het hoofdstuk voor virtual DOM binnen React. --

\subsubsection{\IfLanguageName{dutch}{Wat is DOM?}{What is DOM?}}
\label{sec:watIsDOM}

Meer over het DOM (Data Object Model) van een browser en hoe er mee wordt gecommuniceerd. (JavaScript, compilers, ...)

\subsubsection{\IfLanguageName{dutch}{Virtual DOM}{Virtual DOM}}
\label{sec:virtualDOM}

% KLAD! Uses the render-diff process
% %%%%%%%%%%
Componenten worden geïnjecteerd met data en bevatten stukken van de UI die op basis van die data een bepaalde vorm aannemen. Enkel wanneer de data naar een component veranderd zal deze het stuk van de UI die hij beheert gaan aanpassen. React plaatst dan het geüpdatet component in de virtuele DOM boom, wat een kopie is van de werkelijke DOM boom in de browser, en vergelijkt het de reeds bestaande referentie van het component met de geüpdatet versie. Wanneer er verschillen zijn in structuur tussen de componenten zal er een update gedaan worden van het werkelijke component in het browser DOM.

\section{\IfLanguageName{dutch}{Tools}{Tools}}
\label{sec:toolsOplossingen}

\subsection{\IfLanguageName{dutch}{Webpack}{Webpack}}
\label{sec:webpack}

\subsection{\IfLanguageName{dutch}{Server side renderen}{Server side rendering}}
\label{sec:ssr}
            
